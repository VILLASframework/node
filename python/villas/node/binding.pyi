"""
@generated by mypy (partial). Manual edits applied for function decorators.
isort:skip_file

Author: Kevin Vu te Laar <vu.te@rwth-aachen.de>
SPDX-FileCopyrightText: 2014-2025 Institute for Automation of Complex Power Systems, RWTH Aachen University
SPDX-License-Identifier: Apache-2.0
"""

from _typeshed import Incomplete
from typing import Any, Callable, Optional

Capsule = Any
logger: Incomplete

def _warn_if_not_implemented(
    func: Callable[..., Any],
) -> Callable[..., Any]: ...

class Node:
    class _SampleSlice:
        node: Incomplete
        idx: Incomplete

        def __init__(self, node, idx) -> None: ...
        def details(self): ...
        def read_from(self, sample_length, count: Incomplete | None = None): ...
        def write_to(self, node, count: Incomplete | None = None): ...
        def pack_from(
            self,
            values: float | list[float] | Capsule,
            ts_origin: int | None,
            ts_received: int | None,
            seq: int = 0,
        ): ...
        def unpack_to(
            self,
            target: Capsule,
        ): ...

    config: Incomplete

    def __init__(self, config, uuid: str | None = None, size: int = 0) -> None: ...
    def __del__(self) -> None: ...
    def __getitem__(self, idx: int | slice): ...
    def __setitem__(self, obj) -> None: ...
    def __len__(self) -> int: ...
    def __copy__(self) -> None: ...
    def __deepcopy__(self) -> None: ...
    @staticmethod
    def memory_init(hugepages: int): ...
    def check(self): ...
    def details(self): ...
    def input_signals_max_cnt(self): ...
    def is_enabled(self): ...
    @staticmethod
    def is_valid_name(name: str): ...
    def name(self): ...
    def name_full(self): ...
    def name_short(self): ...
    def output_signals_max_cnt(self): ...
    def pause(self): ...
    def prepare(self): ...
    def read_from(
        self,
        sample_length,
        cnt: int | None = None,
        idx: Incomplete | None = None,
    ): ...
    def restart(self): ...
    def resume(self): ...
    def reverse(self): ...
    def start(self): ...
    def stop(self): ...
    def to_json(self): ...
    def to_json_str(self): ...
    def write_to(
        self,
        node,
        cnt: int | None = None,
        idx: Incomplete | None = None,
    ): ...
    def sample_length(self, idx: int): ...
    def pack_from(
        self,
        idx: int,
        ts_orig: int | None,
        ts_recv: int | None,
        values: float | list[float] | Capsule,
        seq: int = 0,
    ): ...
    def unpack_to(
        self,
        r_idx: int,
        target_node,
        w_idx: int,
    ): ...
    def sample_details(self, idx): ...

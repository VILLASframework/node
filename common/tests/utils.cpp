/** Unit tests for utilities
 *
 * @author Steffen Vogel <stvogel@eonerc.rwth-aachen.de>
 * @copyright 2017-2018, Institute for Automation of Complex Power Systems, EONERC
 * @license GNU General Public License (version 3)
 *
 * VILLAScommon
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *********************************************************************************/

#include <criterion/criterion.h>

#include <villas/crypt.h>
#include <villas/utils.h>

void init_logging();

TestSuite(utils,
	.description = "Utilities",
	.init = init_logging
);

/* Simple normality test for 1,2,3s intervals */
Test(utils, box_muller)
{
	double n;
	unsigned sigma[3] = { 0 };
	unsigned iter = 1000000;

	for (unsigned i = 0; i < iter; i++) {
		n = box_muller(0, 1);

		if      (n > 2 || n < -2) sigma[2]++;
		else if (n > 1 || n < -1) sigma[1]++;
		else                     sigma[0]++;
	}

#if 0
	printf("%f %f %f\n",
		(double) sigma[2] / iter,
		(double) sigma[1] / iter,
		(double) sigma[0] / iter);
#endif

	/* The random variable generated by the Box Muller transform is
	 * not an ideal normal distributed variable.
	 * The numbers from below are empirically measured. */
	cr_assert_float_eq((double) sigma[2] / iter, 0.045527, 1e-2);
	cr_assert_float_eq((double) sigma[1] / iter, 0.271644, 1e-2);
	cr_assert_float_eq((double) sigma[0] / iter, 0.682829, 1e-2);
}

#ifdef __linux__
Test(utils, cpuset)
{
	int ret;
	char str[512];

	cpu_set_t cset1;
	cpu_set_t cset2;
	uintmax_t int1 = 0x1234567890ABCDEFULL;
	uintmax_t int2 = 0;

	cpuset_from_integer(int1, &cset1);

	cpulist_create(str, sizeof(str), &cset1);

	ret = cpulist_parse(str, &cset2, 1);
	cr_assert_eq(ret, 0);

	cr_assert(CPU_EQUAL(&cset1, &cset2));

	cpuset_to_integer(&cset2, &int2);

	cr_assert_eq(int1, int2);
}
#endif /* __linux__ */

Test(utils, memdup)
{
	char orig[1024], *copy;
	size_t len;

	len = read_random(orig, sizeof(orig));
	cr_assert_eq(len, sizeof(orig));

	copy = (char *) memdup(orig, sizeof(orig));
	cr_assert_not_null(copy);
	cr_assert_arr_eq(copy, orig, sizeof(orig));

	free(copy);
}

Test(utils, is_aligned)
{
	/* Positive */
	cr_assert(IS_ALIGNED(1, 1));
	cr_assert(IS_ALIGNED(128, 64));

	/* Negative */
	cr_assert(!IS_ALIGNED(55, 16));
	cr_assert(!IS_ALIGNED(55, 55));
	cr_assert(!IS_ALIGNED(1128, 256));
}

Test(utils, ceil)
{
	cr_assert_eq(CEIL(10, 3), 4);
	cr_assert_eq(CEIL(10, 5), 2);
	cr_assert_eq(CEIL(4, 3), 2);
}

Test(utils, is_pow2)
{
	/* Positive */
	cr_assert(IS_POW2(1));
	cr_assert(IS_POW2(2));
	cr_assert(IS_POW2(64));

	/* Negative */
	cr_assert(!IS_POW2(0));
	cr_assert(!IS_POW2(3));
	cr_assert(!IS_POW2(11111));
	cr_assert(!IS_POW2(-1));
}

Test(utils, strf)
{
	char *buf = NULL;

	buf = strcatf(&buf, "Hallo %s", "Steffen.");
	cr_assert_str_eq(buf, "Hallo Steffen.");

	strcatf(&buf, " Its Monday %uth %s %u.", 13, "August", 2018);
	cr_assert_str_eq(buf, "Hallo Steffen. Its Monday 13th August 2018.");

	free(buf);
}

struct version_param {
	const char *v1, *v2;
	int result;
};

Test(utils, version)
{
	struct version v1, v2, v3, v4;

	version_parse("1.2", &v1);
	version_parse("1.3", &v2);
	version_parse("55",  &v3);
	version_parse("66",  &v4);

	cr_assert_lt(version_cmp(&v1, &v2), 0);
	cr_assert_eq(version_cmp(&v1, &v1), 0);
	cr_assert_gt(version_cmp(&v2, &v1), 0);
	cr_assert_lt(version_cmp(&v3, &v4), 0);
}

Test(utils, sha1sum)
{
	int ret;
	FILE *f = tmpfile();

	unsigned char     hash[SHA_DIGEST_LENGTH];
	unsigned char expected[SHA_DIGEST_LENGTH] = { 0x69, 0xdf, 0x29, 0xdf, 0x1f, 0xf2, 0xd2, 0x5d, 0xb8, 0x68, 0x6c, 0x02, 0x8d, 0xdf, 0x40, 0xaf, 0xb3, 0xc1, 0xc9, 0x4d };

	/* Write the first 512 fibonaccia numbers to the file */
	for (int i = 0, a = 0, b = 1, c; i < 512; i++, a = b, b = c) {
		c = a + b;

		fwrite((void *) &c, sizeof(c), 1, f);
	}

	ret = sha1sum(f, hash);

	cr_assert_eq(ret, 0);
	cr_assert_arr_eq(hash, expected, SHA_DIGEST_LENGTH);

	fclose(f);
}

Test(utils, decolor)
{
	char str[] = "This " CLR_RED("is") " a " CLR_BLU("colored") " " CLR_BLD("text!");
	char expect[] = "This is a colored text!";

	decolor(str);

	cr_assert_str_eq(str, expect);
}
